# 2026-02-16 Project work

## What to do?

- We are still missing a few things in our transformation to lambda_RC:
  - Partial applications 
    - How to assert something is a partial application? Is it enough to just check the syntax of a global function?
      Consider `let myfun = fun x -> fun y -> x + y` or `let myfun = fun x -> let y = ... in fun z -> x + y + z`
    - typechecking?
  - Variable applications (easy: when it is not a 'constant' (top-level) function)
  - Tuple eliminiation (fst, snd) are not in the parser, and should they be?
  - Overapplication of constants - we do nothing for that, typechecking? 
    Try `let tup = (fun x -> x, 2) in fst tup (snd tup)`, that should be `let tup = (fun x -> x, 2) in (fst(tup))(snd tup)`
    but that becomes `fst(tup, var2)`
  - Literals/constant values => we should modify the refcount code to account for these. Right now we are emitting `inc(5)` ... oops
- Other stuff:
  - Pattern matching, translating these to a series of projections ...
    - On that note, signal pattern should probably just be (pattern * string)? Should you be allowed to pattern match on later values?
  - Output, could we do a simple heap? Make Rizzo run? 
